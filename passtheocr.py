# -*- coding: utf-8 -*-
"""PasstheOCR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G2dqIaMLsmmpFp4_RlF-RfA_K-O6sElo

## libs
"""

#!pip install opencv-python-headless tf2onnx doctr

"""## New Section"""

#import shutil
#shutil.rmtree('/content/output')

#from PIL import Image
#import matplotlib.pyplot as plt
#from IPython.display import display
#
## Specify the path of the image
#examplepath = "/content/ex1.png"
#
## Open an image file
#with Image.open(examplepath) as img:
#    img_pdf = img.convert('RGB')
#    img_pdf.save('/content/img_pdf.pdf')
#
## Display the message
#print("Image converted to PDF successfully.")
#
# Display the original image
#display(img)

#pip install opencv-python-headless pdf2image tf2onnx doctr

import os
import numpy as np
from doctr.io import DocumentFile
from doctr.models import ocr_predictor
from PIL import Image, ImageDraw
import pandas as pd
from typing import Any, List, Tuple

def draw_bboxes_on_tiles(csv_path: str, tiles_dir: str) -> None:
    # Load the CSV data
    df = pd.read_csv(csv_path)

    # For each unique tile number
    for tile_num in df['tile_num'].unique():
        # Filter rows for this tile
        tile_df = df[df['tile_num'] == tile_num]

        # Open the corresponding tile image
        tile_image_path = f'{tiles_dir}/tile_{tile_num}.png'
        tile = Image.open(tile_image_path)
        draw = ImageDraw.Draw(tile)

        # Draw each bounding box
        for _, row in tile_df.iterrows():
            draw.rectangle(
                [(row['x1'], row['y1']), (row['x2'], row['y2'])],
                outline="red",
                width=2
            )

            # Optional: Draw the text above the bounding box
            if isinstance(row['text'], str):
                draw.text((row['x1'], row['y1'] - 12), row['text'], fill="red")

        # Display the annotated tile
        tile.show()

        # Save the annotated tile
        tile.save(tile_image_path)

# Function to cut the image into overlapping tiles
def cut_into_overlapping_tiles(image: Any, num_tiles: Tuple[int, int], expected_width: int) -> List[Any]:
    width, height = image.size
    x_tiles, y_tiles = num_tiles
    x_step = width // (x_tiles - 1)
    y_step = height // (y_tiles - 1)

    # Calculate the required overlap to achieve the expected width
    overlap_x = (x_step - expected_width + x_step) // (x_tiles - 1)
    overlap_y = int(0.2 * y_step)  # Keep the vertical overlap unchanged

    pieces = []
    for i in range(y_tiles):
        for j in range(x_tiles):
            left = max(0, j * x_step - overlap_x * (j > 0))
            upper = max(0, i * y_step - overlap_y * (i > 0))
            right = min(width, (j + 1) * x_step + overlap_x * (j < x_tiles - 1))
            lower = min(height, (i + 1) * y_step + overlap_y * (i < y_tiles - 1))

            piece = image.crop((left, upper, right, lower))
            pieces.append(piece)
    return pieces

def main():
    # List PDF files in the "content" folder
    content_folder = '/content'
    pdf_files = [f for f in os.listdir(content_folder) if f.endswith('.pdf')]

    if pdf_files:
        # Use the first PDF file found in the "content" folder
        pdf_path = os.path.join(content_folder, pdf_files[0])

        # Read the PDF file
        docs = DocumentFile.from_pdf(pdf_path)
        model = ocr_predictor(det_arch='db_resnet50', reco_arch='crnn_vgg16_bn', pretrained=True)

        # Convert PDF page to image
        page_image = Image.fromarray(docs[0])

        # Cut the image into overlapping tiles
        desired_num_tiles = (5, 4)
        overlap_ratio = 0.2
        expected_tile_width = 128
        pieces = cut_into_overlapping_tiles(page_image, desired_num_tiles, expected_tile_width)

        # Create the "tiles" directory if it doesn't exist
        tiles_dir = '/content/tiles'
        if not os.path.exists(tiles_dir):
            os.makedirs(tiles_dir)

        # Now calculate the x_step and y_step
        width, height = page_image.size
        x_step = width // (desired_num_tiles[0] - 1)
        y_step = height // (desired_num_tiles[1] - 1)

        # Apply OCR to each piece and display the result
        piece_data = {}  # To store DataFrame for each piece
        for piece_num, piece in enumerate(pieces):
            piece = piece.convert('RGB')
            draw = ImageDraw.Draw(piece)  # Create a draw object to add bounding boxes to the image

            # Get overlap values
            overlap_x = (x_step - expected_tile_width + x_step) // (desired_num_tiles[0] - 1)

            overlap_y = int(0.2 * y_step)  # Keep the vertical overlap unchanged

            # Get the original position of the tile
            i, j = divmod(piece_num, desired_num_tiles[0])
            left = max(0, j * x_step - int(x_step * 0.2) * (j > 0))  # Adjusted for overlap
            upper = max(0, i * y_step - int(y_step * 0.2) * (i > 0))  # Adjusted for overlap
            width, height = page_image.size
            x_tiles, y_tiles = (5, 4)  # Adjust as needed
            x_step = width // (x_tiles - 1)
            y_step = height // (y_tiles - 1)

            piece_np = np.array(piece)
            if len(piece_np.shape) != 3:
                print(f"Skipping piece {piece_num} due to invalid shape: {piece_np.shape}")
                continue

            # Check the shape of the piece
            h, w, c = piece_np.shape
            if w != 128:  # If the width is not 128
                print(f"Piece {piece_num} has unexpected width {w}. Adjusting overlap...")
                # Recalculate this piece with increased overlap to ensure width of 128
                piece = cut_into_overlapping_tiles(page_image, (5, 4), w + 1)[piece_num]
                piece_np = np.array(piece)

            # Perform OCR on the piece
            try:
                result = model([piece_np])
            except Exception as e:
                print(f"Error processing piece {piece_num} with shape {piece_np.shape}: {str(e)}")
                continue

            # Extract the text and coordinates from the OCR result
            data = []
            for block in result.pages[0].blocks:
                for line in block.lines:
                    for word in line.words:
                        coords = word.geometry

                        # Convert normalized coordinates to real-world coordinates for the tile
                        real_x1 = int(coords[0][0] * piece.width)
                        real_y1 = int(coords[0][1] * piece.height)
                        real_x2 = int(coords[1][0] * piece.width)
                        real_y2 = int(coords[1][1] * piece.height)

                        data.append((real_x1, real_y1, real_x2, real_y2, word.value, piece_num))

                        # Draw bounding boxes on the piece
                        draw.rectangle(
                            [real_x1, real_y1, real_x2, real_y2],
                            outline="red",
                            width=2
                        )

            # Create a DataFrame for the current piece and store it in the dictionary
            piece_df = pd.DataFrame(data, columns=['x1', 'y1', 'x2', 'y2', 'text', 'tile_num'])
            piece_data[piece_num] = piece_df

            # Save the tile as a separate PNG file
            piece.save(f'{tiles_dir}/tile_{piece_num}.png')

            # Display the piece with bounding boxes
            #print(f"Piece {piece_num}:")

        # Print the DataFrames for each piece and concatenate them
        all_dfs = []  # Create a list to store all the DataFrames
        for piece_num, df in piece_data.items():
            #print(f"Data for Piece {piece_num}:")
            #print(df)
            #print("\n" + "="*50 + "\n")
            all_dfs.append(df)  # Append each DataFrame to the list

        # Concatenate all the DataFrames into a final DataFrame
        final_df = pd.concat(all_dfs, ignore_index=True)
        final_df.to_csv(f'{content_folder}/final_output.csv', index=False)

        # Now you can call the function
        #draw_bboxes_on_tiles(f'{content_folder}/final_output.csv', tiles_dir)

        # Print the final concatenated DataFrame
        print("Final concatenated DataFrame:")
        print(final_df)
    else:
        print("No PDF files found in the 'content' folder.")

if __name__ == "__main__":
    main()

#import os
#
#def display_directory_tree(directory_path, indent=""):
#    # Get the list of files and subdirectories in the current directory
#    contents = os.listdir(directory_path)
#
#    for item in contents:
#        item_path = os.path.join(directory_path, item)
#        if os.path.isdir(item_path):
#            # If it's a directory, print it and recursively explore its contents
#            print(indent + f"üìÅ {item}")
#            display_directory_tree(item_path, indent + "  |")
#        else:
#            # If it's a file, print it
#            print(indent + f"üìÑ {item}")
#
## Replace 'your_directory_path' with the directory you want to display
#directory_to_display = '/content/'
#if os.path.exists(directory_to_display):
#    display_directory_tree(directory_to_display)
#else:
#    print("Directory not found.")