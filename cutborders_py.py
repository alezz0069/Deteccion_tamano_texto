# -*- coding: utf-8 -*-
"""cutborders.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TJvceoVobiR9gRfiXAPJ8Eq3BG7hGUjq
"""

# Install required libraries
#!pip install pymupdf pdf2image
#!apt-get install -y poppler-utils

import cv2
import numpy as np
import csv
import pandas as pd
from pdf2image import convert_from_path
from IPython.display import Image, display

def preprocess_image(image):
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # Apply additional preprocessing techniques as needed
    return gray_image

def detect_and_filter_lines(gray_image, orientation, threshold_length, gap, thickness_condition, output_csv):
    edges = cv2.Canny(gray_image, 50, 150)
    lines = cv2.HoughLinesP(edges, 1, np.pi / 180, threshold=100, minLineLength=threshold_length, maxLineGap=gap)

    image_height, image_width = gray_image.shape[:2]
    filtered_lines = []

    for line in lines:
        x1, y1, x2, y2 = line[0]
        line_length = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)

        if thickness_condition(x1, y1, x2, y2) and line_length >= 0.85 * (image_width if orientation == 'horizontal' else image_height):
            filtered_lines.append([int(x1), int(y1), int(x2), int(y2), int(line_length)])

    with open(output_csv, 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['start_x', 'start_y', 'end_x', 'end_y', 'length'])
        for line in filtered_lines:
            csv_writer.writerow(line)

    return pd.DataFrame(filtered_lines)

def draw_lines(image, lines, color):
    for line in lines.values:
        cv2.line(image, (int(line[0]), int(line[1])), (int(line[2]), int(line[3])), color, 2)

def create_white_patch(image, result_horizontal, result_vertical):
    # Create a copy of the original image
    image_with_patch = np.copy(image)

    # Get the coordinates of the rectangular area defined by the four lines
    x_min = int(result_vertical['start_x'].min())
    x_max = int(result_vertical['end_x'].max())
    y_min = int(result_horizontal['start_y'].min())
    y_max = int(result_horizontal['end_y'].max())

    # Draw a white rectangle on the copy of the image to cover the area
    cv2.rectangle(image_with_patch, (x_min, y_min), (x_max, y_max), (255, 255, 255), thickness=cv2.FILLED)

    # Display the image with the white patch
    return image_with_patch

def process_pdf(pdf_path):
    # Convert PDF to Image
    images = convert_from_path(pdf_path)
    image = np.array(images[0])  # Assuming there's only one page in the PDF

    # Image Preprocessing
    gray_image = preprocess_image(image)

    # Horizontal Line Detection and Filtering
    result_horizontal = detect_and_filter_lines(gray_image, 'horizontal', 100, 10, lambda x1, y1, x2, y2: abs(y1 - y2) < 5, 'horizontal_lines.csv')

    # Visualization and CSV Output for Horizontal Lines
    draw_lines(image, result_horizontal, (0, 255, 255))
    cv2.imwrite('output_image.png', image)
    #display(Image(filename='output_image.png'))

    # Vertical Line Detection and Filtering
    result_vertical = detect_and_filter_lines(gray_image, 'vertical', 100, 10, lambda x1, y1, x2, y2: abs(x1 - x2) < 5, 'vertical_lines.csv')

    # Visualization and CSV Output for Vertical Lines
    draw_lines(image, result_vertical, (0, 255, 255))
    cv2.imwrite('output_image_vertical.png', image)
    #display(Image(filename='output_image_vertical.png'))

    # Continue with the remaining code

    # Reading data from vertical_lines.csv
    vertical_lines_df = pd.read_csv('vertical_lines.csv')

    # Sorting by 'start_x' column
    sorted_df_vertical = vertical_lines_df.sort_values(by='start_x')

    # Adding a new column for the difference between consecutive 'start_x' values
    sorted_df_vertical['start_x_diff'] = sorted_df_vertical['start_x'].diff()

    # Finding the row with the highest 'start_x_diff' value
    max_diff_row = sorted_df_vertical.loc[sorted_df_vertical['start_x_diff'].idxmax()]

    # Finding the index of the previous row
    prev_index = sorted_df_vertical.index.get_loc(max_diff_row.name) - 1

    # Getting the previous row
    prev_row = sorted_df_vertical.iloc[prev_index]

    # Creating a DataFrame with the two extracted rows
    result_vertical = pd.DataFrame([max_diff_row, prev_row])

    # Displaying the extracted rows
    #print("Extracted rows for vertical lines:")
    #print(result_vertical)
    #display(result_vertical)

    # Reading data from horizontal_lines.csv
    horizontal_lines_df = pd.read_csv('horizontal_lines.csv')

    # Sorting by 'start_y' column
    sorted_df_horizontal = horizontal_lines_df.sort_values(by='start_y')

    # Adding a new column for the difference between consecutive 'start_y' values
    sorted_df_horizontal['start_y_diff'] = sorted_df_horizontal['start_y'].diff()

    # Finding the row with the highest 'start_y_diff' value
    max_diff_row_horizontal = sorted_df_horizontal.loc[sorted_df_horizontal['start_y_diff'].idxmax()]

    # Finding the index of the previous row
    prev_index_horizontal = sorted_df_horizontal.index.get_loc(max_diff_row_horizontal.name) - 1

    # Getting the previous row
    prev_row_horizontal = sorted_df_horizontal.iloc[prev_index_horizontal]

    # Creating a DataFrame with the two extracted rows
    result_horizontal = pd.DataFrame([max_diff_row_horizontal, prev_row_horizontal])

    # Displaying the extracted rows
    #print("Extracted rows for horizontal lines:")
    #print(result_horizontal)
    #display(result_horizontal)

    # Function to draw lines on a copy of the image
    def draw_lines_on_copy(image, lines, color):
        image_copy = np.copy(image)
        for line in lines.values:
            cv2.line(image_copy, (int(line[0]), int(line[1])), (int(line[2]), int(line[3])), color, 2)
        return image_copy

    # Draw horizontal lines with one color
    draw_lines(image, result_horizontal[['start_x', 'start_y', 'end_x', 'end_y']], (0, 255, 0))  # Green for horizontal

    # Draw vertical lines with another color
    draw_lines(image, result_vertical[['start_x', 'start_y', 'end_x', 'end_y']], (255, 0, 0))    # Red for vertical

    # Display the image
    cv2.imwrite('output_image_with_lines.png', image)
    #display(Image(filename='output_image_with_lines.png'))

    # Function to draw lines on a copy of the image
    def draw_lines_on_copy(image, lines, color):
        image_copy = np.copy(image)
        for line in lines.values:
            cv2.line(image_copy, (int(line[0]), int(line[1])), (int(line[2]), int(line[3])), color, 2)
        return image_copy

    # Convert PDF to Image
    image = np.array(images[0])  # Assuming there's only one page in the PDF

    # Draw vertical lines with another color on a copy of the image
    image_with_vertical_lines = draw_lines_on_copy(image, result_vertical[['start_x', 'start_y', 'end_x', 'end_y']], (255, 0, 0))

    # Get bounding box coordinates for the vertical lines
    x_min_vertical = int(result_vertical['start_x'].min())
    x_max_vertical = int(result_vertical['end_x'].max())

    # Trim the image based on the bounding box defined by the vertical lines
    trimmed_image_vertical = image_with_vertical_lines[:, x_min_vertical:x_max_vertical]

    # Draw horizontal lines with one color on a copy of the vertically trimmed image
    image_with_horizontal_lines = draw_lines_on_copy(trimmed_image_vertical, result_horizontal[['start_x', 'start_y', 'end_x', 'end_y']], (0, 255, 0))

    # Get bounding box coordinates for the horizontal lines on the vertically trimmed image
    y_min_horizontal = int(result_horizontal['start_y'].min())
    y_max_horizontal = int(result_horizontal['end_y'].max())

    # Trim the image based on the bounding box defined by the horizontal lines
    trimmed_image = image_with_horizontal_lines[y_min_horizontal:y_max_horizontal, :]

    # Display the final trimmed image without the lines
    cv2.imwrite('final_trimmed_image.png', trimmed_image)
    #display(Image(filename='final_trimmed_image.png'))

    # Create a white patch on the original image
    image_with_patch = create_white_patch(image, result_horizontal, result_vertical)

    # Display the image with the white patch
    cv2.imwrite('image_with_patch.png', image_with_patch)
    #display(Image(filename='image_with_patch.png'))